# 视觉地标导航指令生成任务设计方案

## 1. 任务目标
生成基于显著视觉地标（Salient Visual Landmarks）的导航指令，提高指令的可读性和人类友好度。
**示例**：“Head north on Bajcsy-Zsilinszky út toward Bank u/Podmaniczky Frigyes tér...” -> "Start facing the large white building, walk forward and turn left at the red post office..."

## 2. 核心挑战与策略

| 挑战 | 解决方案 |
| :--- | :--- |
| **全景图序列获取** | 使用 Dijkstra 算法在本地原始拓扑图上规划路径，输出 Pano ID 序列。 |
| **视角朝向控制** | 起点视角对准由Head North决定的第一段路径方向；行进中朝向与移动方向一致。 |
| **VLM 高昂成本** | 采用**离线生成**策略，利用预下载的全景图 + Python 本地渲染，批量生成指令。 |

## 3. 系统架构与流程

### Phase 1: 任务与路径生成 (Task Assembler)

在 `generate_tasks.py` 运行过程中：
1.  **路径规划**：使用 **Dijkstra** 算法在 `raw_metadata_map`（不包含 Virtual Links）上计算从起点到终点的最短路径。
2.  **数据构建**：生成 `visual_path` 字段，包含每一步的 Pano ID 和 Heading。
3.  **Heading 逻辑**：
    *   **Start Frame**: $Heading = Bearing(P_0 \to P_1)$。确保 Agent 起步即面朝正确的方向（如 North）。
    *   **Moving Frame**: 当站在节点 $P_i$ (i > 0) 时，相机朝向为 $Bearing(P_{i-1} \to P_i)$，即**移动方向**（你刚从 $P_{i-1}$ 走过来）。
    *   **Jitter**: 忽略微小抖动。
4.  **存储**：将生成的 Task JSON 存入 `tasks_visual/json/` 子目录。

### Phase 2: 离线图像渲染 (Offline Rendering)

编写脚本 `scripts/render_visual_paths.py`：
1.  **输入**：读取 `tasks_visual/json/` 下的所有 JSON 文件。
2.  **预下载**：检查路径上的全景图是否在本地，若缺失则自动下载（High-Res）。
3.  **渲染**：
    *   使用 Python (OpenCV/py360convert) 加载全景图。
    *   根据 JSON 中的 `view_heading` 裁剪出透视图 (Perspective View)。
    *   **FOV/Size**: 保持与 Agent 输入一致 (e.g., 90° FOV, 640x480)。
4.  **输出**：保存到 `tasks_visual/images/<task_id>/step_<N>.jpg`。

### Phase 3: VLM 指令生成 (Instruction Generation)

编写脚本 `scripts/generate_vlm_instructions.py`：
1.  **构造 Prompt**：
    > "You are a navigation assistant. I will show you a sequence of views along a route. Your goal is to write concise navigation instructions based on SALIENT VISUAL LANDMARKS (e.g., 'Turn left at the red post office'). Do not use street names."
2.  **输入**：按顺序传入渲染好的图片序列。
3.  **输出**：将 VLM 生成的文本回写到 Task JSON 的 `description` 字段。

## 4. 数据结构设计

### Task JSON 新增字段
```json
{
  "task_id": "nav_mcdonalds_20240122_1",
  "task_type": "navigation_to_poi",
  "spawn_heading": 45.0,  // 已修正为 visual_path[0].heading
  "visual_path": [
    {
      "step_index": 0,
      "pano_id": "pid_A",
      "heading": 45.0,    // Bearing(A -> B)
      "next_pano_id": "pid_B",
      "action": "Start"
    },
    {
      "step_index": 1,
      "pano_id": "pid_B",
      "heading": 130.0,   // Bearing(B -> C)
      "next_pano_id": "pid_C",
      "action": "Move Forward"
    }
  ]
}
```

## 5. 目录结构

```
VLN_BENCHMARK/
├── tasks_visual/
│   ├── json/                  # 存储 Task JSON
│   │   └── nav_task_1.json
│   └── images/                # 存储渲染图片
│       └── nav_task_1/
│           ├── step_00_pidA.jpg
│           ├── step_01_pidB.jpg
│           └── ...
```

## 6. 执行计划

1.  **Modify Scheduler**: 更新 `task_assembler.py` 实现 Dijkstra 和 `visual_path` 计算（已完成）。
2.  **Rendering Script**: 开发 `render_visual_paths.py` 实现批量下载与渲染（待开发）。
3.  **VLM Integration**: 开发 VLM 交互脚本（待开发）。
